<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.roblox.com/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Folder" referent="RBXBDD5C7DE776D4BD9B5C6AB1C20D373B4">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
			<bool name="DefinesCapabilities">false</bool>
			<string name="Name">InfiltrationEngine-StateWrangler</string>
			<int64 name="SourceAssetId">-1</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="ModuleScript" referent="RBXFAA439A62C7C40B48A8DAB698F3AF972">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	This module is provided for convenience of consumers of the serializer API
	providing a reference implementation for correctly retrieving and validating a reference to the API table

	For a working example of a plugin making use of this API via this module
	see: https://github.com/Sprixitite/InfiltrationEngine-PrefabSystem
]]

local coreGui = game:GetService("CoreGui")

export type Token = string
export type Hook = (...any) -> nil
export type HookType = "APIExtensionLoaded"|"APIExtensionUnloaded"|"PreSerialize"|"PreSerializeMissionSetup"|"SerializerUnloaded"
export type APIExtension = { [string] : (...any) -> ...any }

export type APIReference = {
	-- Generic
	GetAPIVersion 			: () -> number,
	GetCodeVersion 			: () -> number,
	GetAttributesMap 		: () -> { [string] : { [number] : any } },
	GetAttributeTypes 		: () -> { [string] : number },
	GetRegistrantFactory	: (author: string, plugin: string) -> ((hookName: string) -> string), 

	-- HookTypes
	GetHookTypes 			: () -> { [number] : string },
	IsHookTypeValid 		: (hookType: string, warnCaller: string?) -> boolean,

	-- Hooks
	AddHook 				: (hookType: HookType, registrant: string, hook: Hook, hookState: {any}?) -> Token,
	RemoveHook 				: (token: Token) -> nil,

	-- APIExtensions
	AddAPIExtension 		: (name: string, author: string, contents: APIExtension) -> Token,
	GetAPIExtension			: (name: string, author: string) -> APIExtension,
	RemoveAPIExtension		: (token: Token) -> nil
}

type AnyTbl = { [string] : any }

local APIConsumer = {}

local function ValidateArgTypes(fname: string, ...) : boolean
	local args = {...}
	for _, argSettings in ipairs(args) do
		local argName = argSettings[1]
		local argValue = argSettings[2]
		local argType = type(argValue)
		local argExpectedType = argSettings[3]
		if argType ~= argExpectedType then
			warn(`Invalid argument {argName} passed to function {fname} - expected type {argExpectedType} but got {argType}!`)
			return false
		end
	end
	return true
end

APIConsumer.ValidateArgTypes = ValidateArgTypes

-- Yields until timeOut is elapsed or API is found
APIConsumer.WaitForAPI = function(timeOut: number?) : APIReference?
	timeOut = if timeOut == nil then math.huge else timeOut

	if not ValidateArgTypes(
		"WaitForAPI",
		{"timeOut", timeOut, "number"}
		) then return end

	local presenceIndicator = coreGui:WaitForChild("InfilEngine_SerializerAPIAvailable", timeOut)
	if not presenceIndicator then return end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return end

	return apiTbl
end

-- Attempt to get the API without blocking - returns false + nil if unavailable, otherwise returns true + APIReference
APIConsumer.TryGetAPI = function() : (boolean, APIReference?)
	local presenceIndicator = coreGui:FindFirstChild("InfilEngine_SerializerAPIAvailable")
	if not presenceIndicator then return false, nil end

	local apiTbl = shared.InfilEngine_SerializerAPI
	if not (tostring(apiTbl) == presenceIndicator.Value) then return false, nil end

	return true, apiTbl
end

-- Never returns unless there's an error
-- Continually wires up handling of serializer load/unload as well as unloading of consumer plugin as needed
-- Avoid doing this yourself if you can help it
APIConsumer.DoAPILoop = function<StateT>(
	callerPlugin: Plugin,
	srcname: string,
	loadedClbck: (api: APIReference, state: StateT) -> nil,
	unloadedClbck: (api: APIReference, state: StateT) -> nil, 
	state: StateT?
) : never
	state = if state == nil then {} else state

	if typeof(callerPlugin) ~= "Instance" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {typeof(callerPlugin)}!`)
		return
	end

	if callerPlugin.ClassName ~= "Plugin" then
		warn(`Invalid argument callerPlugin passed to DoAPILoop - expected type Plugin but got {callerPlugin.ClassName}!`)
		return
	end

	if not ValidateArgTypes(
		"DoAPILoop", 
		{"srcname", srcname, "string"},
		{"loadedClbck", loadedClbck, "function"},
		{"unloadedClbck", unloadedClbck, "function"},
		{"state", state, "table"}
		) then return end

	local api = APIConsumer.WaitForAPI()
	if api == nil then return APIConsumer.DoAPILoop(callerPlugin, srcname, loadedClbck, unloadedClbck, state) end

	loadedClbck(api, state)

	local pluginUnloadCallback
	local unloadToken

	pluginUnloadCallback = callerPlugin.Unloading:Connect(function()
		pluginUnloadCallback:Disconnect()
		pluginUnloadCallback = nil
		unloadedClbck(api, state)
		if unloadToken ~= nil then api.RemoveHook(unloadToken) end
	end)

	unloadToken = api.AddHook("SerializerUnloaded", `APIConsumerFramework_{srcname}`, function()
		if pluginUnloadCallback then pluginUnloadCallback:Disconnect() pluginUnloadCallback = nil end
		unloadedClbck(api, state)
		task.spawn(APIConsumer.DoAPILoop, callerPlugin, srcname, loadedClbck, unloadedClbck, state)
	end)
end

return APIConsumer]]></ProtectedString>
				<string name="ScriptGuid">{ACBA5CB7-6E2A-448B-A882-D8EE76336908}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">APIConsumer</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBXE652DA6BBED54A33B2CE44873861DAD9">
			<Properties>
				<ProtectedString name="Source"><![CDATA[local apiConsumer = require(script.Parent.APIConsumer)
local warnLogger = require(script.Parent.Slogger)
warnLogger.init{postInit = table.freeze, logFunc = warn}
local tableWriter = require(script.Parent.TableWriter)
local glut = require(script.Parent.GLUt)

local runService = game:GetService("RunService")

type APIReference = apiConsumer.APIReference

local warn = warnLogger.new("StateWrangler")
glut.configure{ warn = warn }

local hookName = nil

local StateWrangler = {}

function StateWrangler.OnAPILoaded(api: APIReference, wranglerState)
	hookName = hookName or api.GetRegistrantFactory("Sprix", "StateWrangler")
	local hookData = {}
	wranglerState[1] = api.AddHook("PreSerialize", hookName("PreSerialize"), StateWrangler.OnPreSerialize, hookData)
	wranglerState[2] = api.AddHook("PreSerializeMissionSetup", hookName("PreSerializeMissionSetup"), StateWrangler.OnPreSerializeMissionSetup, hookData)
end

function StateWrangler.OnAPIUnloaded(api: APIReference, wranglerState)
	for _, token in ipairs(wranglerState) do
		api.RemoveHook(token)
	end
end

function StateWrangler.OnPreSerialize(callbackState, invokeState, mission: Folder)
	local warn = warn.specialize("OnPreSerialize")
	
	local first = true
	repeat
		if not first then coroutine.yield() end
		local _, present = invokeState.Get("Sprix_PrefabSystem_PreSerialize_Present")
		local success, done = invokeState.Get("Sprix_PrefabSystem_PreSerialize", "Done")
		first = false
	until (not present) or (success and done)
	
	local missionGlobalData = {}
	callbackState.MissionGlobals = missionGlobalData
	
	local missionGlobalFolder = mission:FindFirstChild("MissionGlobals")
	if missionGlobalFolder == nil then return end
	
	for _, child in missionGlobalFolder:GetDescendants() do
		if child:IsA("Folder") then continue end
		
		local warn = warn.specialize(`MissionGlobal {child.Parent}.{child} is invalid`)
		if not child:IsA("StringValue") then
			warn(`Expected type StringValue got {child.ClassName}`, "Value will be ignored")
			continue
		end
		
		local dest = child:GetAttribute("Destination") or "Globals"
		if type(dest) ~= "string" then
			warn(`Destination attribute found, but of unexpected type {type(dest)}`, "Destination will default to Globals")
			dest = "Globals"
		end
		
		missionGlobalData[child.Name] = {
			Destination = glut.str_split(dest, '.'),
			DestinationFull = dest,
			Value = child.Value
		}
	end
	
	missionGlobalFolder:Destroy()
end

function StateWrangler.OnPreSerializeMissionSetup(callbackState, invokeState, missionSetupScript)
	local warn = warn.specialize("OnPreSerializeMissionSetup")
	
	local success, missionSetup = pcall(function() return require(missionSetupScript) end)
	if not success then warn("Error while running MissionSetup", missionSetup) return end
	
	local missionGlobalData = callbackState.MissionGlobals
	if missionGlobalData == nil then return end
	
	for k, v in pairs(missionGlobalData) do
		local value = tostring(v.Value)
		local destFound, dest = glut.tbl_tryindex(missionSetup, unpack(v.Destination))
		local fullDest = v.DestinationFull
		
		if not destFound or not glut.typecheck(dest, "table") then
			warn(`Destination MissionSetup.{fullDest} is invalid - destination must be an already-existing table`, "StateValue will be skipped" )
			continue
		end
		if dest[k] ~= nil then
			warn(`StateWrangler instructed to set Globals.{k} = {v}, but a Global of the same name already exists`, "Global will be skipped")
			continue
		end
		
		print(`StateWrangler : Injecting MissionSetup.{fullDest}[\"{k}\"] = \"{value}\"`)
		dest[tostring(k)] = value
	end
	
	local newSrc = "return " .. tableWriter.write_tbl(missionSetup)
	missionSetupScript.Source = newSrc
end

apiConsumer.DoAPILoop(plugin, "InfiltrationEngine-StateWrangler", StateWrangler.OnAPILoaded, StateWrangler.OnAPIUnloaded)]]></ProtectedString>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<token name="RunContext">0</token>
				<string name="ScriptGuid">{8D0CD310-F870-4F71-8A9E-8CD2B6559D2D}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Main</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXC6BE4FB86BF24A05BCCF6C4646F9A850">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	Slogger, yet another minimal Lua logging module
	Log function + post-init function are configurable, for dealing with the slog that is lua version compatibility
	
	Tested to be compatible with Lua5.1
	Presumed compatible with Lua5.2-5.5/Luajit/Luau
	
	© Sprixitite, 2025
]]

local slogger = {}

local sloggerCfg = {
	postInit = function(tbl) return tbl end,
	logFunc = print
}

local function varargs(...)
	local argCount = select('#', ...)
	local argTbl = { ... }
	local i = 0
	return function()
		i = i + 1
		if i <= argCount then return i, argTbl[i], argCount end
	end, argTbl
end

function slogger.new(...)
	local loggerPrefix = ""
	local varargsIter, argsTbl = varargs(...)
	
	for i, arg in varargsIter do
		loggerPrefix = loggerPrefix .. tostring(arg) .. " : "
	end
	
	local doWarn = function(tbl, ...)
		local finalMsg = ""
		
		for i, arg, argCount in varargs(...) do
			finalMsg = finalMsg .. tostring(arg)
			if i ~= argCount then
				finalMsg = finalMsg .. " : "
			end
		end
		
		sloggerCfg.logFunc(loggerPrefix .. finalMsg)
	end
	
	local specialize = function(...)
		return slogger.new(unpack(argsTbl), ...)
	end
	
	local newLogger = setmetatable({ specialize = specialize }, {__call = doWarn})
	return sloggerCfg.postInit(newLogger)
end

function slogger.init(cfg)
	for k, v in pairs(cfg) do
		if type(sloggerCfg[k]) == type(v) then
			sloggerCfg[k] = v
		end
	end
	return slogger
end

return slogger]]></ProtectedString>
				<string name="ScriptGuid">{952CD0D0-51F6-4816-983D-89B1B2D599FD}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">Slogger</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXD9CADC3186CE43A4858AB68956A9CDB9">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[local TableWriter = {}

local keyWriters = {
	string = function(k)
		if k:match("^[_%a][_%w]+$") then
			return k
		else
			return "[\"" .. k .. "\"]"
		end
	end,
	boolean = function(k)
		return '[' .. tostring(k) .. ']'
	end,
	number = function(k)
		return '[' .. tostring(k) .. ']'
	end,
	["nil"] = function(k)
		return "[nil]"
	end,
}

local valueWriters = {
	string = function(v)
		return "\"" .. tostring(v):gsub("\n", "\\n"):gsub("\t", "\\t"):gsub("\r", "\\r"):gsub("\v", "\\v"):gsub("\f", "\\f") .. "\""
	end,
	table = function(v)
		return TableWriter.write_tbl(v)
	end,
	number = function(v)
		return tostring(v)
	end,
	boolean = function(v)
		return tostring(v)
	end,
	["nil"] = function(v)
		return "nil"
	end,
	Color3 = function(v)
		local r = math.round(v.R*255)
		local g = math.round(v.G*255)
		local b = math.round(v.B*255)
		return `Color3.fromRGB({r},{g},{b})`
	end,
}

function TableWriter.write_key(k)
	local kType = typeof(k)
	local writer = keyWriters[kType]
	if writer then return writer(k) end
	error(`Attempt to write {kType} as key`)
end

function TableWriter.write_value(v)
	local vType = typeof(v)
	local writer = valueWriters[vType]
	if writer then return writer(v) end
	error(`Attempt to write {vType} as value`)
end

function TableWriter.write_kvp(k, v)
	local kStr = TableWriter.write_key(k)
	local vStr = TableWriter.write_value(v)
	return kStr .. '=' .. vStr
end

function TableWriter.is_array(tbl)
	local is_arr = true
	for k, v in pairs(tbl) do
		if type(k) ~= "number" then
			is_arr = false
			break
		end
	end
	return is_arr
end

function TableWriter.tbl_count(tbl)
	local i = 0
	for _, _ in pairs(tbl) do
		i = i + 1
	end
	return i
end

function TableWriter.write_arr(tbl)
	local str = '{'
	for i, v in ipairs(tbl) do
		str = str .. TableWriter.write_value(v)
		if i ~= #tbl then str = str .. ',' end
	end
	str = str .. '}'
	return str
end

function TableWriter.write_tbl(tbl)
	if TableWriter.is_array(tbl) then return TableWriter.write_arr(tbl) end
	
	local n = TableWriter.tbl_count(tbl)
	local i = 0
	local str = '{'
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. TableWriter.write_kvp(k, v)
		if i ~= n then str = str .. ',' end
	end
	str = str .. '}'
	
	return str
end

return TableWriter]]></ProtectedString>
				<string name="ScriptGuid">{C94CDBD0-30D3-45E4-94B6-8CCCA4FF1C7E}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">TableWriter</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
		<Item class="ModuleScript" referent="RBXA694ACDDC9AC4A0082CC3C54543E0216">
			<Properties>
				<Content name="LinkedSource"><null></null></Content>
				<ProtectedString name="Source"><![CDATA[--[[
	GLUt // GoodLuaUtilities // Lua5.1 utilities module
	
	© Sprixitite, 2025
]]

local GLUt = {}

local GLUtCfg = {
	print = print,
	warn  = function(...) print("WARNING", ...) end,
	error = error,
	type  = type
}

local patternSpecChars = { '(', ')', '.', '%', '+', '-', '*', '?', '[', ']', '^', '$' }

function GLUt.configure(tbl)
	for k, v in pairs(tbl) do
		if GLUtCfg[k] ~= nil then
			GLUtCfg[k] = v
		else
			GLUtCfg.warn("Attempt to set invalid GLUtCfg Key \"" .. tostring(k) .. "\"")
		end
	end
end

function GLUt.default(arg, default)
	return (arg == nil) and default or arg
end

function GLUt.typecheck(arg, expected, argName, fName)
	local argType = GLUtCfg.type(arg)
	
	expected = string.gsub(expected, '?', "|nil")
	for _, validType in pairs(GLUt.str_split(expected, '|')) do
		if validType == argType then return true end
	end
	
	if argName ~= nil then
		local w = (GLUtCfg.type(fName)~="string") and "Expected arg \"" or fName .. ": expected arg \""
		GLUtCfg.warn(w .. argName .. "\" of type \"" .. expected .. "\" got type \"" .. argType .. "\"!")
	end
	
	return false
end

function GLUt.vararg_capture(...)
	local n = select('#', ...)
	return n, { ... }
end

function GLUt.vararg_iter(...)
	local n, t = GLUt.vararg_capture(...)
	local i = 0
	return function()
		i = i + 1
		if i <= n then return i, t[i], n end
	end, t
end

function GLUt.str_split(str, separator)
	str = str .. separator
	separator = GLUt.str_escape_pattern(separator)
	
	local substrs = {}
	for substr in string.gmatch(str, "(.-)" .. separator) do
		substrs[#substrs+1] = substr
	end
	return substrs
end

function GLUt.str_escape_pattern(str)
	local escaped = str
	for _, specChar in ipairs(patternSpecChars) do
		local escapedSpec = '%' .. specChar
		escaped = string.gsub(escaped, escapedSpec, (specChar == '%') and "%%" or '%' .. escapedSpec)
	end
	return escaped
end

function GLUt.str_double_substr(str, substr)
	local safe = GLUt.str_escape_pattern(substr)
	return string.gsub(str, safe, safe .. safe)
end

function GLUt.str_isempty(str)
	return string.match(str, "^%s$") ~= nil
end

function GLUt.str_chariter(str)
	local n = #str
	local i = 0
	return function()
		i = i + 1
		if i <= n then return GLUt.str_getchar(str, i) end
	end
end

function GLUt.str_getchar(str, i)
	return string.sub(str, i, i)
end

function GLUt.kvp_tostring(k, v)
	return tostring(k) .. " = " .. tostring(v)
end

function GLUt.tbl_tryindex(tbl, ...)
	local indexing = tbl
	for _, k in GLUt.vararg_iter(...) do
		if GLUtCfg.type(indexing) ~= "table" then
			return false, indexing
		end
		indexing = indexing[tostring(k)]
	end

	return true, indexing
end

function GLUt.tbl_clone(tbl, shallow)
	shallow = GLUt.default(shallow, false)
	
	local cloned = {}
	for k, v in pairs(tbl) do
		if GLUtCfg.type(v) == "table" and not shallow then
			cloned[k] = GLUt.tbl_clone(v, shallow)
		else
			cloned[k] = v
		end
	end
	return cloned
end

function GLUt.tbl_findsize(tbl)
	local i = 0
	for _, _ in pairs(tbl) do i = i + 1 end
	return i
end

local function tbl_tostring(tblName, tbl, levels, level)
	local str = tblName .. " = {"
	local indent = string.rep("  ", level)
	local n = GLUt.tbl_findsize(tbl)
	local i = 0
	for k, v in pairs(tbl) do
		i = i + 1
		str = str .. '\n' .. indent
		if GLUtCfg.type(v) == "table" and levels > level then
			str = str .. tbl_tostring(k, v, levels, level+1)
		else
			str = str .. GLUt.kvp_tostring(k, v)
		end
		if i < n then str = str .. ',' end
	end
	return str
end

function GLUt.tbl_tostring(tbl, levels, tblName)
	GLUt.default(tblName, tostring(tbl))
	return tbl_tostring(tblName, tbl, levels, 1)
end

return GLUt]]></ProtectedString>
				<string name="ScriptGuid">{5EAA06A7-E61C-4D11-9CC8-10AA3EE0D980}</string>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<SecurityCapabilities name="Capabilities">0</SecurityCapabilities>
				<bool name="DefinesCapabilities">false</bool>
				<string name="Name">GLUt</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
		</Item>
	</Item>
</roblox>